// Replace your vehicle fetching function with this:
async function fetchVehicles() {
    if (!showVehicles.checked) return;
    
    loading.style.display = 'block';
    errorMessage.style.display = 'none';
    
    try {
        // Try fetching from specific agencies instead of RG
        // Get a list of monitored agencies from our active agencies
        const monitoredAgencies = agencies
            .filter(a => a.monitored && activeAgencies.has(a.id))
            .slice(0, 3); // Limit to 3 agencies to avoid rate limiting
        
        if (monitoredAgencies.length === 0) {
            throw new Error('No monitored agencies selected');
        }
        
        // Start with an empty vehicles array
        vehicles = [];
        
        // Fetch vehicles for each monitored agency
        for (const agency of monitoredAgencies) {
            try {
                console.log(`Fetching vehicles for ${agency.name} (${agency.id})`);
                
                // Using the SIRI VehicleMonitoring API with specific agency
                const response = await fetch(
                    `https://api.511.org/transit/VehicleMonitoring?api_key=${API_KEY}&agency=${agency.id}&format=json`
                );
                
                if (!response.ok) {
                    console.warn(`API error for ${agency.id}: ${response.status}`);
                    continue;
                }
                
                const data = await response.json();
                processAgencyVehicles(data, agency);
            } catch (agencyError) {
                console.warn(`Error fetching vehicles for agency ${agency.id}:`, agencyError);
                // Continue with next agency instead of failing completely
            }
        }
        
        // If we didn't get any vehicles, throw an error to trigger the fallback
        if (vehicles.length === 0) {
            throw new Error('No vehicles found from any agencies');
        }
        
        // Update UI
        updateVehicleMarkers();
        updateNearbyVehiclesList();
        
        // Update status
        const now = new Date();
        lastUpdate.textContent = `Last updated: ${now.toLocaleTimeString()}`;
        vehicleCount.textContent = `${vehicles.length} vehicles tracked`;
        
        // Hide loading and error if shown
        loading.style.display = 'none';
        errorMessage.style.display = 'none';
        
    } catch (error) {
        console.error('Error fetching vehicles:', error);
        useDemoVehicles();
    }
}

// Add this new function to process vehicles from a specific agency
function processAgencyVehicles(data, agency) {
    if (!data || !data.Siri || !data.Siri.ServiceDelivery || 
        !data.Siri.ServiceDelivery.VehicleMonitoringDelivery || 
        !data.Siri.ServiceDelivery.VehicleMonitoringDelivery.VehicleActivity) {
        console.warn(`Invalid vehicle data format for agency ${agency.id}`);
        return;
    }
    
    // Handle both array and single object responses
    const vehicleActivities = Array.isArray(data.Siri.ServiceDelivery.VehicleMonitoringDelivery.VehicleActivity) 
        ? data.Siri.ServiceDelivery.VehicleMonitoringDelivery.VehicleActivity
        : [data.Siri.ServiceDelivery.VehicleMonitoringDelivery.VehicleActivity];
    
    vehicleActivities.forEach(activity => {
        if (!activity.MonitoredVehicleJourney) return;
        
        const journey = activity.MonitoredVehicleJourney;
        
        // Skip vehicles without location data
        if (!journey.VehicleLocation || 
            !journey.VehicleLocation.Latitude || 
            !journey.VehicleLocation.Longitude) return;
        
        // Ensure latitude and longitude are valid numbers
        const lat = parseFloat(journey.VehicleLocation.Latitude);
        const lng = parseFloat(journey.VehicleLocation.Longitude);
        
        if (isNaN(lat) || isNaN(lng)) return;
        
        // Check if latitude and longitude are in reasonable bounds for Bay Area
        if (lat < 36.5 || lat > 38.5 || lng < -123.0 || lng > -121.0) return;
        
        const vehicle = {
            id: journey.VehicleRef || `${agency.id}-${Math.random().toString(36).substring(2, 9)}`,
            agency: agency.id,
            agencyName: agency.name,
            color: agency.color,
            position: {
                lat: lat,
                lng: lng
            },
            bearing: journey.Bearing || 0,
            route: journey.LineRef || 'Unknown',
            destination: journey.DestinationName || 'Unknown',
            timestamp: activity.RecordedAtTime
        };
        
        vehicles.push(vehicle);
    });
    
    console.log(`Added ${vehicleActivities.length} vehicles from ${agency.name}`);
}

// Modify the fetchAgencies function to better handle errors
async function fetchAgencies() {
    loading.style.display = 'block';
    errorMessage.style.display = 'none';
    
    try {
        const response = await fetch(`https://api.511.org/transit/operators?api_key=${API_KEY}&format=json`);
        
        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }
        
        let data = await response.json();
        
        // Check if the data is in the expected format
        if (!Array.isArray(data)) {
            // If it's not an array, it might be wrapped in a 'content' property
            // or be in some other unexpected format
            if (data.content && Array.isArray(data.content)) {
                data = data.content;
            } else {
                console.warn('Unexpected API response format:', data);
                throw new Error('Unexpected API response format');
            }
        }
        
        // Process agencies data - format varies
        agencies = data.map(agency => ({
            id: agency.Id || agency.id,
            name: agency.Name || agency.name,
            color: agencyColors[agency.Id || agency.id] || getRandomColor(),
            monitored: agency.Monitored === 'true' || agency.Monitored === true
        })).filter(agency => {
            // Filter out non-transit agencies or internal IDs
            return agency.id !== '5E' && agency.id !== '5F' && agency.id !== '5O' && agency.id !== '5S';
        });
        
        // Sort agencies alphabetically
        agencies.sort((a, b) => a.name.localeCompare(b.name));
        
        // Initialize active agencies
        activeAgencies = new Set(agencies.map(a => a.id));
        
        // Update UI
        populateAgencyUI();
        
        // Fetch initial data
        fetchVehicles();
        if (showStops.checked) {
            fetchStopsForActiveAgencies();
        }
        
    } catch (error) {
        console.error('Error fetching agencies:', error);
        useFallbackAgencies();
    } finally {
        loading.style.display = 'none';
    }
}

// Modified function to handle loading GTFS feeds for specific routes
async function fetchStops(agencyId) {
    if (!showStops.checked) return;
    
    try {
        const response = await fetch(`https://api.511.org/transit/stops?api_key=${API_KEY}&operator_id=${agencyId}&format=json`);
        
        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Check for different data formats and handle accordingly
        if (data.Contents && data.Contents.dataObjects && data.Contents.dataObjects.ScheduledStopPoint) {
            // Handle NeTEx format
            const stopsData = Array.isArray(data.Contents.dataObjects.ScheduledStopPoint) 
                ? data.Contents.dataObjects.ScheduledStopPoint 
                : [data.Contents.dataObjects.ScheduledStopPoint];
            
            processNeTexStops(stopsData, agencyId);
        } else if (Array.isArray(data)) {
            // Handle GeoJSON format
            processStops(data, agencyId);
        } else {
            console.error('Unknown stops data format for agency:', agencyId, data);
        }
        
    } catch (error) {
        console.error(`Error fetching stops for agency ${agencyId}:`, error);
    }
}

// Add a function to process NeTEx format stops
function processNeTexStops(stopsData, agencyId) {
    // Find agency info
    const agency = agencies.find(a => a.id === agencyId) || {
        name: agencyId,
        color: agencyColors[agencyId] || '#999999'
    };
    
    // Process each stop
    stopsData.forEach(stop => {
        if (!stop.Location || !stop.Location.Latitude || !stop.Location.Longitude || !stop.id) return;
        
        const stopObj = {
            id: stop.id,
            name: stop.Name || 'Unknown Stop',
            agency: agencyId,
            agencyName: agency.name,
            position: {
                lat: parseFloat(stop.Location.Latitude),
                lng: parseFloat(stop.Location.Longitude)
            },
            lines: ''
        };
        
        stops.push(stopObj);
        
        // Add stop marker to the map
        const marker = L.marker([stopObj.position.lat, stopObj.position.lng], {
            icon: createStopIcon(),
            title: stopObj.name
        });
        
        marker.bindPopup(`
            <strong>${stopObj.name}</strong><br>
            ${stopObj.agencyName}
        `);
        
        stopLayer.addLayer(marker);
    });
    
    console.log(`Added ${stopsData.length} stops for ${agency.name}`);
}
